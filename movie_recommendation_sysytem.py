# -*- coding: utf-8 -*-
"""Movie_Recommendation_Sysytem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yVQrFmdxwYTuHKj1frfGMysZxUFvBr57

# **Title of Project**

Movie Recommendation System

-------------

## **Objective**

The objective of this project is to recommend movies to users based on their ratings of previously watched movies. We will use a collaborative filtering approach, leveraging user-item interactions to suggest similar movies.

## **Data Source**

The dataset we are using is the MovieLens dataset, which contains user ratings for different movies. We'll use the 100k dataset version for simplicity.

## **Import Library**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from math import sqrt

"""## **Import Data**"""

# Load MovieLens 100k dataset
url = "https://files.grouplens.org/datasets/movielens/ml-100k/u.data"
column_names = ['user_id', 'movie_id', 'rating', 'timestamp']
data = pd.read_csv(url, sep='\t', names=column_names, engine='python')

# Load movie titles
movie_titles_url = "https://files.grouplens.org/datasets/movielens/ml-100k/u.item"
movie_titles = pd.read_csv(movie_titles_url, sep='|', header=None, encoding='latin-1', usecols=[0, 1], names=['movie_id', 'title'])

# Merge movie titles with ratings data
data = pd.merge(data, movie_titles, on='movie_id')

# Display the first few rows of the merged data
data.head()

"""## **Describe Data**"""

# Check basic statistics of the data
data.describe()

"""## **Data Visualization**"""

plt.figure(figsize=(10, 4))
sns.countplot(x='rating', data=limited_data)
plt.title('Distribution of Movie Ratings (Limited Data)')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.show()

"""## **Data Preprocessing**"""

# Drop unnecessary columns (e.g., timestamp)
data.drop('timestamp', axis=1, inplace=True)

# Create a user-movie matrix (rows: users, columns: movies)
user_movie_matrix = data.pivot_table(index='user_id', columns='title', values='rating')
user_movie_matrix.fillna(0, inplace=True)

user_movie_matrix.head()

"""## **Define Target Variable (y) and Feature Variables (X)**"""

# For collaborative filtering, we use the user-movie matrix as the feature (X) and ratings as the target (y).
X = user_movie_matrix.values
y = data['rating']

"""## **Train Test Split**"""

# Split the data into training and testing sets
X_train, X_test = train_test_split(user_movie_matrix, test_size=0.2, random_state=42)

"""## **Modeling**"""

from sklearn.neighbors import NearestNeighbors

# Fit the KNN model on the full user-movie matrix (not X_train)
model_knn = NearestNeighbors(metric='cosine', algorithm='brute')
model_knn.fit(user_movie_matrix.T)

"""## **Model Evaluation**"""

# Define the function to get movie recommendations
def get_movie_recommendations(movie_name, data_matrix, model):
    movie_index = data_matrix.columns.get_loc(movie_name)  # Get index of the movie
    distances, indices = model.kneighbors(data_matrix.T.iloc[movie_index, :].values.reshape(1, -1), n_neighbors=6)

    print(f"Recommendations for {movie_name}:")
    for i in range(1, len(distances.flatten())):
        print(f"{i}: {data_matrix.columns[indices.flatten()[i]]}")

# Example: Get recommendations for "Star Wars (1977)"
get_movie_recommendations("Star Wars (1977)", user_movie_matrix, model_knn)

"""## **Prediction**"""

# We can extend the recommendation function to recommend movies to a specific user based on their preferences.
# For simplicity, this is currently returning recommendations based on similar movies.

"""## **Explaination**

This project implemented a basic collaborative filtering model using the K-Nearest Neighbors algorithm.
The model recommends movies based on user-item interactions, calculating the similarity between movies.
"""